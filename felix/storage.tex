\setchapterstyle{kao}
\setchapterpreamble[u]{\margintoc}

\chapter{External Storage}

\section{Interfacing the SD Card}
\label{sec:interfacing-the-sd-card}

Most of the information in the following section was taken from \href{http://www.elm-chan.org/docs/mmc/mmc_e.html}{www.elm-chan.org/docs/mmc/mmc\_e.html}

A \gls{sdc} or \gls{mmc} is an easy way to store data on embedded systems. More powerful devices use the card in SD mode, which allows faster clock speeds, but microcontrollers mostly use the SPI mode, because of the already existing SPI hardware module. Since all SD devices only operate at voltages between 2.7 and 3.3 volts, a voltage translation has to be added in between the Arduino and the device. For this, a SD card adapter from AZ-Delivery was used. By reverse engineering it, following schematic could be reconstructed:

% include schematic

This adapter has two problems however. First, the voltage translation only goes in one way, so the MISO line still operates at 3.3V. Second, the bus buffer gate outputs are configured to be always in low impedance mode, which leads to problems, when more than two devices are communicating on the MOSI line.

The commands used to communicate with the SD device is build up of a 6-bit command index, an 4-byte argument and a 7-bit \gls{crc}. For example a CMD0 consists of "insert here how commands are build up and image". After the command was send, the SD device sends an response within the \gls{ncr}, which is at most 8 bytes. During this time CLK has to be active and CS has to stay low. Then, the card sends a one or four byte response and depending on the command also a data packet up to 2051 bytes long.

\newcommand{\sdcmdvert}[1]{\draw[gray, dotted] (#1, 1.5) -- (#1, 1.2) (#1, -.2) -- (#1,-.8) (#1,-2.2) -- (#1,-2.8) (#1,-3.2) -- (#1,-3.6);}
\newcommand{\sdcmdverta}[1]{\draw[gray, dotted] (#1, 1.5) -- (#1, .1) (#1, -.2) -- (#1,-.8) (#1,-2.2) -- (#1,-2.8) (#1,-3.2) -- (#1,-3.6);}
\newcommand{\sdcmdvertb}[1]{\draw[gray, dotted] (#1, 1.5) -- (#1, 1.2) (#1, -.2) -- (#1,-.8) (#1,-1.2) -- (#1,-2.8) (#1,-3.2) -- (#1,-3.6);}
\newcommand{\sdcmdvertc}[1]{\draw[gray, dotted] (#1, 1.5) -- (#1, 1.2) (#1, -.2) -- (#1,-.8) (#1,-1.2) -- (#1,-2.8) (#1,-4.2) -- (#1,-4.5);}
\begin{figure}[h!]
  \centering
  \resizebox{\textwidth}{!}{
  \begin{tikztimingtable}[timing/yunit = 5mm, timing/xunit = 2.5mm]
    CLK  & lllll 15{c} 32{0.5c 0.5c} 49{c} lll\\
    MOSI & hhhh L N[rectangle, above, xshift=-1.2mm]{0} H N[rectangle, below, xshift=-1mm]{1} 6D{\Large Index} 16D{\Large Argument} 7D{\Large CRC}H N[rectangle, below, xshift=-1mm]{1} 36h\\
    MISO & hhhh 5{16h} L N[rectangle, above, xshift=-1mm]{0}7D{\Large Flags} hhhh\\
    \extracode
    \foreach \t in {25,45,65} {
      \sdcmdvert{\t mm}
    }
    \sdcmdvertc{105mm}
    \sdcmdvertc{125mm}
    \sdcmdvertb{85mm}
    \sdcmdverta{5mm}
    \sdcmdvert{35mm}
    \sdcmdvert{55mm}
    \fill[white] (93mm,1.5) .. controls (87mm,-1) and (97mm,-2) .. (93mm,-4.5) -- (97mm,-4.5) .. controls (101mm,-2) and (91mm,-1) .. (97mm,1.5);
    \draw[gr50] (93mm,1.5) .. controls (87mm,-1) and (97mm,-2) .. (93mm,-4.5);
    \draw[gr50] (97mm,-4.5) .. controls (101mm,-2) and (91mm,-1) .. (97mm,1.5);
    \draw[gr50] (6mm,2.5) -- (84mm,2.5) (45mm, 2.5) node[rectangle, gr70, fill=white]{Command};
    \draw[gr50] (86mm,2.5) -- (104mm,2.5) (95mm,2.5) node[rectangle, gr70, fill=white]{NCR};
    \draw[gr50] (106mm,2.5) -- (124mm,2.5) (115mm,2.5) node[rectangle, gr70, fill=white]{R1};
    \draw[gr50] (25mm, -4.2) -- (27mm,-4.5) -- (63mm,-4.5) -- (65mm,-4.2) (45mm,-4.5) node[rectangle, fill=white]{scaled 2x};
  \end{tikztimingtable}}
  \caption{Bottom text}
  \label{fig:sd-command}
\end{figure}

\subsection{Initializing}
\label{sec:initializing}

Before any commands can be send to the SD card, it has to be put into SPI mode by setting both MOSI and CS high and toggling CLK for at least 74 clock cycles. To start the initialization process, a CMD0 command has to be send, followed by a CMD8 to detect the kind of device. If it responds with an "Illegal command" flag, the device is a SDv1, otherwise it is a SDv2. The next step is to send a CMD55 followed by a CMD41, until the card leaves idle mode. This usually has to be done at least twice. 

\begin{marginfigure}
    \centering
    \resizebox{!}{8cm}{
    \begin{tikzpicture}[node distance = 2cm]
      \node(start)[startstop]{Power on};
      \node(cmd0)[process, below of = start]{CMD0};
      \node(cmd8)[process, below of = cmd0]{CMD8};
      \node(isillegal)[decision, below of = cmd8]{Is illegal?};
      \node(acmd41)[process, right of = isillegal, xshift=.5cm, yshift=-2cm]{ACMD41};
      \node(idlestate)[decision, below of = acmd41]{In idle state?};
      \node(done)[startstop, below of = idlestate]{Done};
      \node(sdv1)[process, left of = isillegal, xshift = -.5cm, yshift=-2cm]{SDv1};
      \node(notsupported)[startstop, below of = sdv1]{Not supported};
    
      \draw [arrow] (start) -- (cmd0);
      \draw [arrow] (cmd0) -- (cmd8);
      \draw [arrow]  (cmd8) -- (isillegal);
      \draw [arrow] (isillegal) node[above, xshift=2cm]{no} -| (acmd41);
      \draw [arrow] (acmd41) -- (idlestate);
      \draw [arrow] (idlestate.east) -- ++(1,0) node[above, xshift=-5mm]{yes} |- (acmd41);
      \draw [arrow] (idlestate) -- node[right]{no} (done);
      \draw [arrow] (isillegal) node[above, xshift=-2cm]{yes} -| (sdv1);
      \draw [arrow] (sdv1) -- (notsupported);
    \end{tikzpicture}}
    \caption{Caption}
\end{marginfigure}



\subsection{Reading from the Card}

\todo{find difference between block and sector}
The SD card manages its data in so called block, which are usually chunks of 512 bytes. Those blocks can be read one at a time or as a continuous data stream, but the filesystem library Petit FatFs requires the read function to perform single block reads, so multiple block reading won't be discussed further.

In order to read a single block, CMD17 has to be send to the card along with the sector number as argument. The card should respond with 0x00 and shortly after sends the requested data packet consisting of a 0xFE, 512 bytes of data and a 2-byte \gls{crc}.





\section{File System}

\subsection{FAT}

The \gls{fat} file system is one of the most basic file systems. There are \gls{fat} 12, 16 and 32, while \gls{fat} 12 was only ever used on old devices like floppy disks. Because of its simplicity it is very often used for small portable storage devices like USB drives or SD cards. 

The disk starts with the File Allocation Table, which contains a map of all clusters % what is cluster
in the system. One cell of the table represents a cluster and shows it's allocation status. Following the File Allocation Table are two types of clusters: data and directory cluster. Directory clusters store the structure of the file tree and give information about the files, while data clusters hold the actual file content.

\subsection{FatFs}

In order to interface this file system a very popular library called FatFs was used. Because of the limited resources available on the low-powered microcontrollers, a smaller version called Petit FatFs was used instead. All information about this library as well as its documentation can be found on \href{http://elm-chan.org/}{elm-chan.org}.

As FatFs was written to be as portable as possible it does not provide any communication with the storage device. Therefore the user has to implement the communication layer by themselves. % is correct?
The communication layer has to provide the following functions:

\begin{tabular}{ll}
    \cinline{disk_initialize} &  Initializes the SD card as described in section \ref{sec:initializing}\\
    \cinline{disk_readp} & Reads a partial sector at a specific address\\
    \cinline{disk_writep} & Writes a partial sector at a specific address\\
\end{tabular}

\subsubsection{Using FatFs}

\begin{marginfigure}
    \centering
    \resizebox{4cm}{!}{
    \begin{tikzpicture}[node distance = 2cm]
      \node(start)[startstop]{Start};
      \node(pfmount)[command, below of = start]{pf\_mount()};
      \node(pfopendir)[command, below of = pfmount]{pf\_opendir()};
      \node(pfreaddir)[command, below of = pfopendir]{pf\_readdir()};
      \node(allfilesread)[decision, below of = pfreaddir, aspect = 2]{All files read?};
      \node(resetpointer)[process, below of = allfilesread, yshift=-3mm]{Reset file poniter};
      \node(pfreaddir2)[command, below of = resetpointer]{pf\_readdir()};
      \node(allfilesread2)[decision, below of = pfreaddir2, aspect = 2]{All files read?};
      \node(chosefile)[process, below of = allfilesread2, yshift=-3mm]{Chose a file};
      \node(pfopen)[command, below of = chosefile]{pf\_open()};
      \node(pfread)[command, below of = pfopen]{pf\_read()};
      \node(stop)[startstop, below of = pfread]{Done};
    
      \draw [arrow] (start) -- (pfmount);
      \draw [arrow] (pfmount) -- (pfopendir);
      \draw [arrow] (pfopendir) -- (pfreaddir);
      \draw [arrow] (pfreaddir) -- (allfilesread);
      \draw [arrow] (allfilesread.east) node[above right]{no} -- ++(1,0) node(allfilesreadedge){} |- (pfreaddir);
      \draw [arrow] (allfilesread) -- node[right]{yes} (resetpointer);
      \draw [arrow] (resetpointer) -- (pfreaddir2);
      \draw [arrow] (pfreaddir2) -- (allfilesread2);
      \draw [arrow] (allfilesread2.east) node[above right]{no} -- ++(1,0) node(allfilesreadedge2){} |- (pfreaddir2);
      \draw [arrow] (allfilesread2) -- node[right]{yes} (chosefile);
      \draw [arrow] (chosefile) -- (pfopen);
      \draw [arrow] (pfopen) -- (pfread);
      \draw [arrow] (pfread) -- (stop);
    
      \node [fit=(pfreaddir) (allfilesread) (allfilesreadedge), draw, dotted, darkgray, thick, rounded corners, inner sep = 2mm](firstbox){};
      \node[rotate = 90, above] at (firstbox.west){Get number of files};
      \node [fit=(pfreaddir2) (allfilesread2) (allfilesreadedge2), draw, dotted, darkgray, thick, rounded corners, inner sep = 2mm](secondbox){};
      \node[rotate = 90, above] at (secondbox.west){Read file information};
    \end{tikzpicture}
    }
    \caption{Caption}
    \label{fig:my_label}
\end{marginfigure}

Before any operations can be done on the SD card, it needs to be mounted with the function  \cinline{pf_mount(FATFS* fs)}, where \cinline{fs} is the working area of FatFs. Since the file to be played should be chosen interactively, all file information has to be read out first. In order to read a directory it has to be opened with \cinline{pf_opendir(DIR* dp, const char* path)}.

To read the directory's content, the function \cinline{pf_readdir (DIR* dp, FILINFO* fno)} is used, which reads the next directory entry on each call. %It writes all available file information into *fno. After it read all entries it returns an empty file name. Because there are no variable length arrays C++ for AVR, the number of files has to be determined in order to store their information. That can be done by counting how often \cinline{pf_readdir} returns a valid file name. This information can then be used to allocate a data structure of the correct size.

In order to reread all directory entries and save their file names and file sizes, the internal directory index has to be rewound by calling \cinline{pf_readdir} and passing a null pointer instead of \cinline{*fno}. All important file information can then be saved by again repeatedly calling \cinline{pf_readdir}. 

After choosing a file with the interactive menu as described in chapter \ref{ch:user-interface}, the file has to be read in memory. First, the selected file has to be opened with \cinline{pf_open(const char* path)}. After the needed memory has been allocated, the file can be read with \cinline{pf_read(void* buff, UINT btr, UINT *br)}.