\setchapterstyle{kao}
\setchapterpreamble[u]{\margintoc}

\chapter{External Storage}

\section{Interfacing the SD Card}
\label{sec:interfacing-the-sd-card}

\subsection{Initializing}
\begin{tikzpicture}[node distance = 2cm]
  \node(start)[startstop]{Power on};
  \node(cmd0)[process, below of = start]{CMD0};
  \node(cmd8)[process, below of = cmd0]{CMD8};
  \node(isillegal)[decision, below of = cmd8]{Is illegal?};
  \node(acmd41)[process, right of = isillegal, xshift=1cm, yshift=-1.5cm]{ACMD41};
  \node(idlestate)[decision, below of = acmd41]{In idle state?};
  \node(done)[startstop, below of = idlestate]{Done};
  \node(sdv1)[process, left of = isillegal, xshift = -1cm, yshift=-1.5cm]{SDv1};
  \node(notsupported)[startstop, below of = sdv1]{Not supported};

  \draw [arrow] (start) -- (cmd0);
  \draw [arrow] (cmd0) -- (cmd8);
  \draw [arrow]  (cmd8) -- (isillegal);
  \draw [arrow] (isillegal) node[above, xshift=2cm]{no} -| (acmd41);
  \draw [arrow] (acmd41) -- (idlestate);
  \draw [arrow] (idlestate.east) -- ++(1,0) node[above, xshift=-5mm]{yes} |- (acmd41);
  \draw [arrow] (idlestate) -- node[right]{no} (done);
  \draw [arrow] (isillegal) node[above, xshift=-2cm]{yes} -| (sdv1);
  \draw [arrow] (sdv1) -- (notsupported);
\end{tikzpicture}

\subsection{Reading from the Card}

clusters\sidenote{A cluster is block of data which usually contains 512 Bytes}

\section{File System}

\subsection{FAT}

The FAT\sidenote{short for File Allocation Table} file system is one of the most basic file systems. There are FAT 12, 16 and 32, while FAT 12 was only ever used on old devices like floppy disks. Because of its simplicity it is very often used for small portable storage devices like USB drives or SD cards. 

The disk starts with the File Allocation Table, which contains a map of all clusters in the system. One cell of the table represents a cluster and shows it's allocation status. Following the File Allocation Table are two types of clusters: data and directory cluster. Directory clusters store the structure of the file tree and give information about the files, while data clusters hold the actual file content.

\subsection{FatFs}

In order to interface this file system a very popular library called FatFs was used. Because of the limited resources available on the low-powered microcontrollers, a smaller version called Petit FatFs was used instead. All information about this library as well as its documentation can be found on \href{http://elm-chan.org/}{elm-chan.org}.

As FatFs was written to be as portable as possible it does not provide any communication with the storage device. Therefore the user has to implement the communication layer by themselves. % is correct?
The communication layer has to provide the following functions:

\begin{tabular}{ll}
    \lstinline[language=C]!disk_initialize! &  Initializes the SD card as described in section \ref{sec:interfacing-the-sd-card}\\
    \lstinline[language=C]!disk_readp! & Reads a partial sector at a specific address\\
    \lstinline[language=C]!disk_writep! & Writes a partial sector at a specific address\\
\end{tabular}

\begin{marginfigure}
    \centering
    \resizebox{4cm}{!}{
    \begin{tikzpicture}[node distance = 2cm]
      \node(start)[startstop]{Start};
      \node(pfmount)[command, below of = start]{pf\_mount()};
      \node(pfopendir)[command, below of = pfmount]{pf\_opendir()};
      \node(pfreaddir)[command, below of = pfopendir]{pf\_readdir()};
      \node(allfilesread)[decision, below of = pfreaddir, aspect = 2]{All files read?};
      \node(resetpointer)[process, below of = allfilesread, yshift=-3mm]{Reset file poniter};
      \node(pfreaddir2)[command, below of = resetpointer]{pf\_readdir()};
      \node(allfilesread2)[decision, below of = pfreaddir2, aspect = 2]{All files read?};
      \node(chosefile)[process, below of = allfilesread2, yshift=-3mm]{Chose a file};
      \node(pfopen)[command, below of = chosefile]{pf\_open()};
      \node(pfread)[command, below of = pfopen]{pf\_read()};
      \node(stop)[startstop, below of = pfread]{Done};
    
      \draw [arrow] (start) -- (pfmount);
      \draw [arrow] (pfmount) -- (pfopendir);
      \draw [arrow] (pfopendir) -- (pfreaddir);
      \draw [arrow] (pfreaddir) -- (allfilesread);
      \draw [arrow] (allfilesread.east) node[above right]{no} -- ++(1,0) node(allfilesreadedge){} |- (pfreaddir);
      \draw [arrow] (allfilesread) -- node[right]{yes} (resetpointer);
      \draw [arrow] (resetpointer) -- (pfreaddir2);
      \draw [arrow] (pfreaddir2) -- (allfilesread2);
      \draw [arrow] (allfilesread2.east) node[above right]{no} -- ++(1,0) node(allfilesreadedge2){} |- (pfreaddir2);
      \draw [arrow] (allfilesread2) -- node[right]{yes} (chosefile);
      \draw [arrow] (chosefile) -- (pfopen);
      \draw [arrow] (pfopen) -- (pfread);
      \draw [arrow] (pfread) -- (stop);
    
      \node [fit=(pfreaddir) (allfilesread) (allfilesreadedge), draw, dotted, darkgray, thick, rounded corners, inner sep = 2mm](firstbox){};
      \node[rotate = 90, above] at (firstbox.west){Get number of files};
      \node [fit=(pfreaddir2) (allfilesread2) (allfilesreadedge2), draw, dotted, darkgray, thick, rounded corners, inner sep = 2mm](secondbox){};
      \node[rotate = 90, above] at (secondbox.west){Read file information};
    \end{tikzpicture}
    }
    \caption{Caption}
    \label{fig:my_label}
\end{marginfigure}

Before any operations can be done on the SD card, it needs to be mounted with the function  \cinline{pf_mount(FATFS* fs)}, where \cinline{fs} is the working area of FatFs. Since the file to be played should be chosen interactively, all file information has to be read out first. In order to read a directory it has to be opened with \cinline{pf_opendir(DIR* dp, const char* path)}.

To read the directory's content, the function \cinline{pf_readdir (DIR* dp, FILINFO* fno)} is used, which reads the next directory entry on each call. %It writes all available file information into *fno. After it read all entries it returns an empty file name. Because there are no variable length arrays C++ for AVR, the number of files has to be determined in order to store their information. That can be done by counting how often \cinline{pf_readdir} returns a valid file name. This information can then be used to allocate a data structure of the correct size.

In order to reread all directory entries and save their file names and file sizes, the internal directory index has to be rewound by calling \cinline{pf_readdir} and passing a null pointer instead of \cinline{*fno}. All important file information can then be saved by again repeatedly calling \cinline{pf_readdir}. 

After choosing a file with the interactive menu as described in chapter \ref{ch:user-interface}, the file has to be read in memory. First, the selected file has to be opened with \cinline{pf_open(const char* path)}. After the needed memory has been allocated, the file can be read with \cinline{pf_read(void* buff, UINT btr, UINT *br)}.